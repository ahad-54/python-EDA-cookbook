# -*- coding: utf-8 -*-
"""chap2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-qsmStHayQqCcnVmZ__jSpQcipfGK98t
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""# **CSV File**"""

data = pd.read_csv('carsdata.csv')
data.head()

"""# **Subset For Relative columns**

"""

cd = data [['Maker','Reg_year',	'Adv_month','Color','Runned_Miles','Wheelbase','Length','Top_speed','Seat_num','Average_mpg']]
cd.head(10)

cd.head()

cd.info()

cd.dtypes

cd.shape

cd.columns = cd.columns.str.strip().str.replace(' ', '_')
#we use this if our data in file have empty spaces it add underscroll between them
print(cd.columns.tolist())

"""
**Checking the Runned Miles of cars based on registration year**"""

cd.groupby('Reg_year')['Runned_Miles'].mean()

"""# **Average Number of cars Per color**
The average number of cars per color means how many cars have same color. It shows which color cars are more popular among customers. A higher average indicates a popular car color, while a lower average shows less demand for that colored cars.

Means it tells us the mean number of cars for each car.

For example, if:

Color A had 50 cars,

Color B had 20 cars,

Color C had 30 cars, then the average cars per color = (50 + 20 + 30) ÷ 3 = 33.3 pickups.

It tells how popular a color of car is on average. The higher the number, the more popular the colo is for cars.

# **Why we used it**
Identify the more popular colors among customers.  

Resource Allocation like the company can produce more cars to high-demand color cars.

"""

cars_percolor = cd['Color'].value_counts()
print("No. of cars with different colors:")
print(cars_percolor)
average_carcolor = cars_percolor.mean()
print(f"Average number of cars per color: {average_carcolor:.2f}")

"""# **Importing CSV file again for new functions**"""

cd1 = pd.read_csv("carsdata.csv")
cd1.head()

cd2 = pd.read_csv("carsdata2.csv")
cd2.tail()

cd1.shape

cd2.shape

"""# **Appending**:
Appending means adding more rows (new data) to our existing dataset (DataFrame).

It does not replace data, it just extends it.

Appending in my dataset means adding new cars data rows (trips) to the existing file so that you have one combined dataset for analysis.

Appending use only for adding the rows.

for Example:-
Suppose in my dataset df has these columns:Maker	Genmodel	Genmodel_ID	Adv_ID	Adv_year	Adv_month	Color	Reg_year	Bodytype	Runned_Miles	...	Engine_power	Annual_Tax	Wheelbase	Height	Width	Length	Average_mpg	Top_speed	Seat_num	Door_num


If i get new cars records from the next day or another source,i can append them to the existing dataset.

# **Why we use Appending?**
We use appending for update dataset with new cars data.

To combine multiple CSVs into one dataset.

To grow dataset for analysis (trends, averages, prediction).
"""

appended_data = pd.concat([cd1, cd2])

appended_data.shape

appended_data.head()

"""# **Concatenating**:
Concatenation in Pandas means joining two or more datasets together.

By default it stacks them row-wise (one below another like appending).

But it can also work column-wise (side by side) if needed.

According to my dataset:-
# **According to my dataset:-**

If i have cars data from Day 1 and Day 2, concatenation combines them into one dataset (row-wise).

And if i have different information about the same rides in separate files (e.g, one file has cars details another has payment info) concatenation can also join them column-wise.

Concatenation means joining datasets either row by row or column by column.

In my ride carsdata dataset it is used to combine multiple days rides (rows) or to add new attributes (columns) to the same cars data.
"""

carsdata1 = pd.read_csv("carsdata.csv")
carsdata2 = pd.read_csv("carsdata2.csv")

concatenated_data = pd.concat([carsdata1, carsdata2], axis = 1)

concatenated_data.shape

"""# **Merging**
Merging means joining two datasets (tables) together using a common column (like an ID). It’s like matching rows from both tables where the key values are the same. This helps bring related information into one table.

For example; In my data set i joins both left and right index because in my datasets i-e carsdata and carsdata2, in both datasets has no similar column, so thats why
I am mergimg the index's.


"""

merged_data = pd.merge(carsdata1,carsdata2, left_index=True, right_index=True)
merged_data.head()

merged_data.shape

"""# **Sorting**:
Sorting means arranging data in a particular order so it becomes organized and easy to understand.

It can be ascending order (smallest to largest A to Z) or descending order (largest to smallest Z to A).

Sorting organizes information to make it easier to read, compare, and analyze.

# **Logic Behind This Code:-**
 In my dataset it help us to understand sorting the cars registered year based on theirmaker from earliest to longest (ascending=False). After sorting it only shows the Reg_year and Maker columns.


"""

cd = data [['Maker','Reg_year',	'Adv_month','Color','Runned_Miles','Wheelbase','Length','Top_speed','Seat_num','Average_mpg']]
cd.head()

sorted_data = cd.sort_values('Reg_year', ascending=False)

sorted_data[['Maker','Reg_year']]

"""# **Categorising Data:**
 Categorizing data means grouping data into different categories or classes based on some criteria. It helps organize information so it is easier to analyze or compare.

Examples:

Grouping rides as Short, Medium, Long based on distance.

Grouping customers by Age: Child, Teen, Adult.

Grouping Booking Value as Low, Medium, High.

It turns raw data into meaningful groups to make analysis easier.

# What this code does:-
In my data set i categorize car's condition based on its runned miles:
"""

cd['bins'] = pd.cut(x=cd['Runned_Miles'], bins=[10,47006,94003,141000],
                               labels = ['New', 'Mid', 'Old'])

cd[['Runned_Miles','bins']].head()

"""# **Removing duplicates**
The below function is used to remove the duplicates data from our rows.


"""

marketing_data_duplicate = cd.drop_duplicates()
marketing_data_duplicate

marketing_data_duplicate.shape

"""# **Deleting or Droping Rows :**
Dropping rows and columns means removing unwanted data from our dataset.

Dropping rows means it deletes specific rows, usually based on index or condition.

Example: removing cars without registration year.

Dropping columns means deletes entire columns that are not needed.

# **In the below code: **

The function removes a column like Seat_num.

"""

cd = data [['Maker','Reg_year',	'Adv_month','Color','Runned_Miles','Wheelbase','Length','Top_speed','Seat_num','Average_mpg']]
cd.head()

"""# **Deleting a specified rows at index values 1**"""

cd.drop(labels=[1], axis=0)

"""# **Deleting a single column :**
In the below code,I removed Adv_month using drop function.
"""

cd.drop(labels=['Adv_month'], axis=1)

"""# **Changing Data Format :-**
In Changing data Format, we are converting the float into integer and we fill the missing values with fillna(0) and change its dtype into integer with astype(int)

The below code fill NAN in the Booking Value column with 0(Zero).

# **Filling NAs in the Adv_month column**
"""

cd['Adv_month'] = cd['Adv_month'].fillna(0)

"""# **Changing the data type of the Income from float to int**

"""

cd['Adv_month_changed'] = cd['Adv_month'].astype(int)

cd[['Adv_month','Adv_month_changed']].head()

cd[['Adv_month','Adv_month_changed']].dtypes

"""# **Subset for relevant columns**

"""

cars_data = data[['Maker','Reg_year','Color','Runned_Miles','Top_speed']]
cars_data.head(10)

cars_data.shape

"""# **Replacing Data :**
Replacing data means changing specific values in our dataset with new ones usually to fix errors or standardize information.

For example:

In my data set I change the Maker name to the new one that help us for better understanding.
"""

cars_data['Maker_replaced'] = cd['Maker'].replace(['Bentley','Land Rover'],['Bently car','RangeRover']).copy()

cars_data[['Maker','Maker_replaced']].head()

"""# **Checking for missing values**
By using below function,we found out the missing values in colums in the relevent subset values.
"""

cars_data.isnull().sum()

"""# **Droping Missing values**
By using below function,we removed the missing values colums in the relevent subset values.
"""

cars_data_withoutna = cars_data.dropna(how = 'any')
cars_data_withoutna.head()

cars_data_withoutna.shape

